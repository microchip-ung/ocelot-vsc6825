//Copyright (c) 2004-2020 Microchip Technology Inc. and its subsidiaries.
//SPDX-License-Identifier: MIT



#include "common.h"     /* Always include common.h at the first place of user-defined herder files */
#include "timer.h"
#include "print.h"

#include "phydrv.h"
#include "phy_base.h"
#include "phy_family.h"

#define PHY_DEBUG (0)

#if VTSS_ATOM12

/************************************************************************/
/* ATOM12 family functions                                              */
/************************************************************************/

#if VTSS_ATOM12_A
static void luton26_vga_patch_appendix(uchar phy)
{
#if PERFECT_REACH_LNK_UP
    //if (Use10BASE_Te) //Configure for reduced-amplitude 10BASE-Te
    {
        phy_write(phy, 31, 0x52b5);

        // TrWrite 0 P1_8 -1 'd50-32
        // TrWrite 0 P1_9 -1 'd42-32
        // TrWrite 0 toggle_dac_sign -1 'd0
        phy_write(phy, 18, 0x0);
        phy_write(phy, 17, 0x0914);
        phy_write(phy, 16, 0x848a);

        // TrWrite 0 P2_14 -1 'd29+32
        // TrWrite 0 P2_15 -1 'd31+32
        // TrWrite 0 P2_16 -1 'd29+32
        // TrWrite 0 P2_17 -1 'd29+32
        phy_write(phy, 18, 0xf7);
        phy_write(phy, 17, 0xff7d);
        phy_write(phy, 16, 0x848c);

        // TrWrite 0 P2_18 -1 'd25+32
        // TrWrite 0 P2_19 -1 'd25+32
        phy_write(phy, 18, 0x0);
        phy_write(phy, 17, 0xe79);
        phy_write(phy, 16, 0x848e);

        // TrWrite 0 P3_0 -1 'd57-32
        // TrWrite 0 P3_1 -1 'd54-32
        // TrWrite 0 P3_2 -1 'd54-32
        // TrWrite 0 P3_3 -1 'd54-32
        phy_write(phy, 18, 0x65);
        phy_write(phy, 17, 0x6596);
        phy_write(phy, 16, 0x8490);

        // TrWrite 0 P3_4 -1 'd54-32
        // TrWrite 0 P3_5 -1 'd50-32
        // TrWrite 0 P3_6 -1 'd50-32
        // TrWrite 0 P3_7 -1 'd50-32
        phy_write(phy, 18, 0x59);
        phy_write(phy, 17, 0x2492);
        phy_write(phy, 16, 0x8492);

        // TrWrite 0 P3_8 -1 'd50-32
        // TrWrite 0 P3_9 -1 'd42-32
        // TrWrite 0 P3_10 -1 'd0
        // TrWrite 0 P3_11 -1 'd10+32
        phy_write(phy, 18, 0x48);
        phy_write(phy, 17, 0xa02a);
        phy_write(phy, 16, 0x8494);

        // TrWrite 0 P4_14 -1 'd29+32
        // TrWrite 0 P4_15 -1 'd31+32
        // TrWrite 0 P4_16 -1 'd29+32
        // TrWrite 0 P4_17 -1 'd29+32
        phy_write(phy, 18, 0xf7);
        phy_write(phy, 17, 0xff7d);
        phy_write(phy, 16, 0x8498);

        // TrWrite 0 P4_18 -1 'd25+32
        // TrWrite 0 P4_19 -1 'd25+32
        phy_write(phy, 18, 0x0);
        phy_write(phy, 17, 0xe79);
        phy_write(phy, 16, 0x849a);

        // TrWrite 0 P5_0 -1 'd53-32
        // TrWrite 0 P5_1 -1 'd53-32
        // TrWrite 0 P5_2 -1 'd53-32
        // TrWrite 0 P5_3 -1 'd53-32
        phy_write(phy, 18, 0x55);
        phy_write(phy, 17, 0x5555);
        phy_write(phy, 16, 0x849c);

        // TrWrite 0 P5_4 -1 'd53-32
        // TrWrite 0 P5_c -1 'd53-32
        phy_write(phy, 18, 0x0);
        phy_write(phy, 17, 0x555);
        phy_write(phy, 16, 0x849e);

        // TrWrite 0 P6_c -1 'd53-32
        phy_write(phy, 18, 0x0);
        phy_write(phy, 17, 0x15);
        phy_write(phy, 16, 0x84a0);

        // TrWrite 0 P8_4 -1 'd63-32
        // TrWrite 0 P8_5 -1 'd63-32
        // TrWrite 0 P8_6 -1 'd63-32
        // TrWrite 0 P8_7 -1 'd63-32
        phy_write(phy, 18, 0x7d);
        phy_write(phy, 17, 0xf7df);
        phy_write(phy, 16, 0x84ae);

        // TrWrite 0 P8_8 -1 'd61-32
        // TrWrite 0 P8_9 -1 'd57-32
        // TrWrite 0 P8_10 -1 'd54-32
        // TrWrite 0 P8_11 -1 'd54-32
        phy_write(phy, 18, 0x75);
        phy_write(phy, 17, 0x9596);
        phy_write(phy, 16, 0x84b0);

        // TrWrite 0 P8_12 -1 'd54-32
        // TrWrite 0 P8_13 -1 'd54-32
        // TrWrite 0 P8_14 -1 'd54-32
        // TrWrite 0 P8_15 -1 'd54-32
        phy_write(phy, 18, 0x59);
        phy_write(phy, 17, 0x6596);
        phy_write(phy, 16, 0x84b2);

        // TrWrite 0 P8_16 -1 'd54-32
        // TrWrite 0 P8_17 -1 'd54-32
        // TrWrite 0 P8_18 -1 'd54-32
        // TrWrite 0 P8_19 -1 'd54-32
        phy_write(phy, 18, 0x59);
        phy_write(phy, 17, 0x6596);
        phy_write(phy, 16, 0x84b4);

        phy_write(phy, 31, 0x2);
        phy_write(phy, 17, 0x8000);
    }
#else
    //else //Configure for fully Cat3 (and uglier) backward-compatible 10BASE-T
    {
        phy_write(phy, 31, 0x52b5);

        // TrWrite 0 P1_8 -1 'd50-32
        // TrWrite 0 P1_9 -1 'd42-32
        // TrWrite 0 toggle_dac_sign -1 'd0
        phy_write(phy, 18, 0x0);
        phy_write(phy, 17, 0x0914);
        phy_write(phy, 16, 0x848a);

        // TrWrite 0 P2_14 -1 'd29+32
        // TrWrite 0 P2_15 -1 'd31+32
        // TrWrite 0 P2_16 -1 'd29+32
        // TrWrite 0 P2_17 -1 'd26+32
        phy_write(phy, 18, 0xf7);
        phy_write(phy, 17, 0xff7a);
        phy_write(phy, 16, 0x848c);

        // TrWrite 0 P2_18 -1 'd22+32
        // TrWrite 0 P2_19 -1 'd18+32
        phy_write(phy, 18, 0x0);
        phy_write(phy, 17, 0xdb2);
        phy_write(phy, 16, 0x848e);

        // TrWrite 0 P3_0 -1 'd50-32
        // TrWrite 0 P3_1 -1 'd50-32
        // TrWrite 0 P3_2 -1 'd48-32
        // TrWrite 0 P3_3 -1 'd48-32
        phy_write(phy, 18, 0x49);
        phy_write(phy, 17, 0x2410);
        phy_write(phy, 16, 0x8490);

        // TrWrite 0 P3_8 -1 'd48-32
        // TrWrite 0 P3_9 -1 'd42-32
        // TrWrite 0 P3_10 -1 'd0
        // TrWrite 0 P3_11 -1 'd10+32
        phy_write(phy, 18, 0x40);
        phy_write(phy, 17, 0xa02a);
        phy_write(phy, 16, 0x8494);

        // TrWrite 0 P4_14 -1 'd29+32
        // TrWrite 0 P4_15 -1 'd31+32
        // TrWrite 0 P4_16 -1 'd29+32
        // TrWrite 0 P4_17 -1 'd26+32
        phy_write(phy, 18, 0xf7);
        phy_write(phy, 17, 0xff7a);
        phy_write(phy, 16, 0x8498);

        // TrWrite 0 P4_18 -1 'd22+32
        // TrWrite 0 P4_19 -1 'd18+32
        phy_write(phy, 18, 0x0);
        phy_write(phy, 17, 0xdb2);
        phy_write(phy, 16, 0x849a);

        // TrWrite 0 P8_4 -1 'd63-32
        // TrWrite 0 P8_5 -1 'd63-32
        // TrWrite 0 P8_6 -1 'd63-32
        // TrWrite 0 P8_7 -1 'd63-32
        phy_write(phy, 18, 0x7d);
        phy_write(phy, 17, 0xf7df);
        phy_write(phy, 16, 0x84ae);

        // TrWrite 0 P8_8 -1 'd61-32
        // TrWrite 0 P8_9 -1 'd57-32
        // TrWrite 0 P8_10 -1 'd53-32
        // TrWrite 0 P8_11 -1 'd51-32
        phy_write(phy, 18, 0x75);
        phy_write(phy, 17, 0x9553);
        phy_write(phy, 16, 0x84b0);
    }
#endif
}


/************************************************************************/
/* ATOM family functions                                               */
/************************************************************************/

// Atom  Rev. A. Internal 8051 patch.(From James M, 13-10-2010)
// In     : port_no - any port within the chip where to load the 8051 code.
// Return : VTSS_RC_OK if configuration done else error code.


// Download patch into PRAM for the internal 8051
static vtss_rc atom_8051_patch_13_10_2010(uchar phy)
{
    // Use "code" qualifier to put vga_arr into ROM.
    //    Use "const" qualifier for memory area (data, idata, xdata)
    //    Reference: http://www.keil.com/support/man/docs/c51/c51_le_const.htm
    code uchar vga_arr[] = {
        0x45, 0xcc, 0x02, 0x44, 0xef, 0x02, 0x40, 0xeb, 0x02, 0x45,
        0x74, 0x90, 0x47, 0xd3, 0xe0, 0x54, 0x7f, 0x44, 0x10, 0xf0,
        0x90, 0x47, 0xd7, 0xe0, 0x54, 0xdf, 0x44, 0x1c, 0xf0, 0xa3,
        0xe0, 0x54, 0x7f, 0xf0, 0xa3, 0xe0, 0x54, 0xfe, 0x44, 0xe6,
        0xf0, 0xa3, 0xe0, 0x54, 0xc6, 0x44, 0xd0, 0xf0, 0xa3, 0xe0,
        0x54, 0xbf, 0x44, 0x31, 0xf0, 0xa3, 0xa3, 0xe5, 0x51, 0x30,
        0xe0, 0x0e, 0xe0, 0x54, 0xbe, 0x44, 0x86, 0xf0, 0xa3, 0xa3,
        0xe0, 0x44, 0x02, 0xf0, 0x80, 0x06, 0xe0, 0x54, 0xfe, 0x44,
        0x06, 0xf0, 0x12, 0x2c, 0xbb, 0x90, 0x47, 0xd5, 0xe0, 0x44,
        0x80, 0xf0, 0x12, 0x27, 0x12, 0x02, 0x2c, 0xb4, 0x90, 0x47,
        0xd2, 0xe0, 0x44, 0x02, 0xf0, 0x90, 0x47, 0xd7, 0xe0, 0x54,
        0x1f, 0xf0, 0xa3, 0xe0, 0x54, 0xfe, 0x44, 0x06, 0xf0, 0xa3,
        0xe0, 0x54, 0xdf, 0x44, 0x1c, 0xf0, 0x90, 0x47, 0xdc, 0xe0,
        0x44, 0x58, 0xf0, 0xa3, 0xe5, 0x50, 0x30, 0xe0, 0x0e, 0xe0,
        0x54, 0xbb, 0x44, 0x83, 0xf0, 0xa3, 0xe0, 0x44, 0x71, 0x54,
        0x7d, 0x80, 0x0a, 0xe0, 0x44, 0xc7, 0xf0, 0xa3, 0xe0, 0x44,
        0x73, 0x54, 0x7f, 0xf0, 0xa3, 0xe0, 0x44, 0xc0, 0xf0, 0xa3,
        0xe5, 0x50, 0x30, 0xe0, 0x07, 0xe0, 0x54, 0xdb, 0x44, 0x9b,
        0x80, 0x03, 0xe0, 0x44, 0xbf, 0xf0, 0xa3, 0x74, 0x24, 0xf0,
        0xa3, 0xe0, 0x54, 0xdf, 0x44, 0x50, 0xf0, 0x12, 0x29, 0xfe,
        0x90, 0x47, 0xd6, 0xe0, 0x44, 0x08, 0xf0, 0x12, 0x27, 0x12,
        0x90, 0x47, 0xdc, 0xe0, 0x54, 0xbf, 0xf0, 0x02, 0x29, 0xf7,
        0x04, 0x76, 0x05, 0xf8, 0x76, 0x02, 0x75, 0x51, 0x02, 0x74,
        0x03, 0x02, 0x06, 0xa6, 0xd5, 0x25, 0x03, 0x75, 0x25, 0x0c,
        0xc2, 0x02, 0x7b, 0xbb, 0x7d, 0x0e, 0x7f, 0x04, 0x12, 0x31,
        0x16, 0xef, 0x60, 0x03, 0x02, 0x44, 0x98, 0xf5, 0x18, 0x75,
        0x1d, 0xa1, 0xe5, 0x18, 0xc3, 0x94, 0x0c, 0x40, 0x03, 0x02,
        0x44, 0x98, 0xa8, 0x1d, 0xe6, 0x20, 0xe7, 0x03, 0x02, 0x44,
        0x91, 0xd2, 0x02, 0x85, 0x18, 0xfb, 0x7f, 0x80, 0x7e, 0x06,
        0x12, 0x2f, 0x0b, 0xe5, 0x4a, 0x54, 0x07, 0x60, 0x05, 0xe5,
        0x4a, 0x30, 0xe2, 0x06, 0x75, 0x24, 0x88, 0x02, 0x44, 0x8d,
        0x7d, 0x1c, 0xe4, 0xff, 0x12, 0x31, 0xee, 0x8e, 0x21, 0x8f,
        0x22, 0xe5, 0x21, 0x13, 0x13, 0x13, 0x54, 0x0c, 0x44, 0x80,
        0xf5, 0x24, 0xe4, 0xf5, 0x19, 0x7f, 0x82, 0x7e, 0x07, 0x12,
        0x2f, 0x0b, 0xe5, 0x4a, 0x54, 0x3f, 0x24, 0xfd, 0x60, 0x4b,
        0x24, 0xf7, 0x60, 0x39, 0x24, 0xdc, 0x70, 0x5b, 0xa8, 0x1d,
        0xe6, 0x54, 0x03, 0x64, 0x03, 0x60, 0x1d, 0x7d, 0x0a, 0xe4,
        0xff, 0x12, 0x31, 0xee, 0xee, 0x30, 0xe6, 0x08, 0x43, 0x24,
        0x0b, 0x75, 0x19, 0x0d, 0x80, 0x6e, 0xe5, 0x24, 0x54, 0x04,
        0x44, 0x83, 0xf5, 0x24, 0x80, 0x07, 0xa8, 0x1d, 0xe6, 0x54,
        0x8f, 0xf5, 0x24, 0xe5, 0x4b, 0x54, 0x0c, 0x70, 0x57, 0x80,
        0x52, 0x43, 0x24, 0x02, 0xe5, 0x4b, 0x54, 0x03, 0x70, 0x08,
        0x75, 0x19, 0x03, 0x80, 0x03, 0x43, 0x24, 0x01, 0xa8, 0x1d,
        0xe6, 0xff, 0x65, 0x24, 0x54, 0x03, 0x60, 0x05, 0x75, 0x19,
        0x09, 0x80, 0x35, 0xef, 0x20, 0xe4, 0x31, 0x80, 0x2c, 0xe5,
        0x4a, 0x54, 0x0c, 0x64, 0x04, 0x70, 0x24, 0x43, 0x24, 0x20,
        0xa8, 0x1d, 0xe6, 0x30, 0xe5, 0x1b, 0x7f, 0xf8, 0x7e, 0x0f,
        0x12, 0x2f, 0x0b, 0xe5, 0x4a, 0x54, 0x0f, 0x64, 0x03, 0x60,
        0x04, 0x7f, 0x01, 0x80, 0x02, 0x7f, 0x00, 0xef, 0x60, 0x03,
        0x43, 0x24, 0x40, 0x75, 0x19, 0x03, 0xe5, 0x24, 0x20, 0xe5,
        0x14, 0xa8, 0x1d, 0xe6, 0x54, 0x60, 0xff, 0xbf, 0x20, 0x0b,
        0xe5, 0x24, 0x54, 0x03, 0x64, 0x02, 0x60, 0x03, 0x43, 0x24,
        0x40, 0xa8, 0x1d, 0xe5, 0x24, 0x44, 0x10, 0xff, 0x66, 0x70,
        0x0c, 0x8f, 0x24, 0xe5, 0x25, 0x14, 0x65, 0x18, 0x60, 0x03,
        0xe4, 0xf5, 0x19, 0x74, 0x95, 0x25, 0x18, 0xf5, 0x1e, 0xe5,
        0x24, 0x54, 0x03, 0xff, 0xbf, 0x03, 0x05, 0x75, 0x1a, 0xff,
        0x80, 0x0d, 0xe5, 0x24, 0x30, 0xe2, 0x04, 0x7f, 0x11, 0x80,
        0x02, 0x7f, 0x22, 0x8f, 0x1a, 0xe4, 0xfd, 0x7f, 0x01, 0x12,
        0x31, 0xee, 0xef, 0xf5, 0x17, 0xaf, 0x19, 0x15, 0x19, 0xef,
        0xd3, 0x94, 0x00, 0x50, 0x03, 0x02, 0x44, 0x6d, 0xe5, 0x18,
        0x54, 0x0c, 0xc4, 0x54, 0xf0, 0x44, 0x20, 0xfa, 0x7b, 0x00,
        0x7d, 0x1c, 0x7f, 0x04, 0x12, 0x32, 0x06, 0xe4, 0xf5, 0x1b,
        0xf5, 0x1c, 0x74, 0x01, 0x7e, 0x00, 0xa8, 0x1c, 0x08, 0x80,
        0x05, 0xc3, 0x33, 0xce, 0x33, 0xce, 0xd8, 0xf9, 0xff, 0xef,
        0x55, 0x1a, 0x60, 0x74, 0xe5, 0x1c, 0x75, 0xf0, 0x40, 0xa4,
        0x24, 0x08, 0xff, 0xe4, 0x35, 0xf0, 0xef, 0xfa, 0xe5, 0x17,
        0xfb, 0xe4, 0xfd, 0x7f, 0x01, 0x12, 0x32, 0x06, 0xe5, 0x18,
        0x54, 0x0c, 0xf5, 0xfb, 0x7d, 0x03, 0x7f, 0x01, 0x12, 0x31,
        0xee, 0xee, 0x54, 0x80, 0xf5, 0x21, 0xef, 0x54, 0x1f, 0xf5,
        0x22, 0xe5, 0x21, 0x44, 0x04, 0x12, 0x44, 0xb1, 0xf5, 0x23,
        0xe5, 0x21, 0x44, 0x20, 0x12, 0x44, 0xb1, 0x25, 0x23, 0xf5,
        0x27, 0xe4, 0x33, 0xf5, 0x26, 0xc3, 0xe5, 0x27, 0x94, 0xea,
        0xe5, 0x26, 0x94, 0x01, 0x50, 0x0f, 0xaf, 0x1c, 0x74, 0x01,
        0xa8, 0x07, 0x08, 0x80, 0x02, 0xc3, 0x33, 0xd8, 0xfc, 0x42,
        0x1b, 0xab, 0x22, 0xaa, 0x21, 0x7d, 0x03, 0x7f, 0x01, 0x12,
        0x32, 0x06, 0x85, 0x18, 0xfb, 0xe5, 0x17, 0x12, 0x44, 0xd8,
        0x05, 0x1c, 0xe5, 0x1c, 0xc3, 0x94, 0x04, 0x50, 0x03, 0x02,
        0x42, 0x6f, 0xe5, 0x1a, 0x54, 0x0f, 0xb5, 0x1b, 0x0a, 0x43,
        0x24, 0x10, 0xa8, 0x1e, 0xe4, 0xf6, 0x02, 0x44, 0x6d, 0xe5,
        0x19, 0x70, 0x40, 0xa8, 0x1e, 0x06, 0xe6, 0xc3, 0x94, 0x50,
        0x50, 0x03, 0x02, 0x44, 0x6d, 0xe5, 0x24, 0x54, 0x0b, 0xff,
        0x60, 0x0c, 0x64, 0x09, 0x60, 0x08, 0xef, 0x64, 0x0a, 0x60,
        0x03, 0x02, 0x44, 0x6d, 0xe5, 0x24, 0x7a, 0x1b, 0x30, 0xe2,
        0x04, 0x7b, 0x30, 0x80, 0x02, 0x7b, 0x38, 0x7d, 0x05, 0x7f,
        0x01, 0x12, 0x32, 0x06, 0x7b, 0x20, 0x7a, 0x1b, 0x7d, 0x05,
        0x7f, 0x01, 0x12, 0x32, 0x06, 0x80, 0xb5, 0xc2, 0x00, 0xc2,
        0x01, 0xe5, 0x24, 0x54, 0x03, 0x24, 0xfe, 0x60, 0x1b, 0x14,
        0x70, 0x31, 0xe5, 0x1b, 0x75, 0xf0, 0x10, 0xa4, 0xff, 0xe5,
        0xf0, 0xf5, 0x26, 0xe5, 0x1b, 0x4f, 0xf5, 0x27, 0x75, 0x21,
        0x00, 0x75, 0x22, 0x0f, 0x80, 0x55, 0x75, 0x26, 0x0c, 0x75,
        0x27, 0x00, 0xe5, 0x24, 0x7e, 0x00, 0x30, 0xe2, 0x04, 0x7f,
        0x01, 0x80, 0x02, 0x7f, 0x02, 0x8e, 0x21, 0x8f, 0x22, 0x80,
        0x3c, 0xe4, 0xf5, 0x26, 0xf5, 0x27, 0xe5, 0x24, 0x20, 0xe5,
        0x06, 0xa8, 0x1e, 0xe6, 0x30, 0xe3, 0x17, 0xe5, 0x24, 0x30,
        0xe2, 0x06, 0x7e, 0xce, 0x7f, 0x81, 0x80, 0x04, 0x7e, 0x3d,
        0x7f, 0x42, 0x8e, 0x21, 0x8f, 0x22, 0xd2, 0x01, 0x80, 0x15,
        0xe5, 0x24, 0x30, 0xe2, 0x06, 0x7e, 0xce, 0x7f, 0x90, 0x80,
        0x04, 0x7e, 0x3d, 0x7f, 0x60, 0x8e, 0x21, 0x8f, 0x22, 0xd2,
        0x00, 0x12, 0x44, 0xe3, 0x12, 0x44, 0xcc, 0x12, 0x45, 0xa5,
        0x7d, 0x1c, 0xe4, 0xff, 0x12, 0x31, 0xee, 0xee, 0x13, 0x13,
        0x13, 0x54, 0x1f, 0xff, 0xef, 0x65, 0x24, 0x20, 0xe2, 0x7a,
        0x7b, 0x00, 0x7a, 0x80, 0x7d, 0x0f, 0x7f, 0x01, 0x12, 0x32,
        0x06, 0xe5, 0x17, 0x44, 0x01, 0x12, 0x44, 0xd8, 0x7f, 0x1e,
        0x12, 0x45, 0xb9, 0xe5, 0x1a, 0x42, 0x27, 0xe4, 0x12, 0x44,
        0xcc, 0x7f, 0x14, 0x12, 0x45, 0xb9, 0x12, 0x45, 0xa5, 0x30,
        0x00, 0x05, 0x43, 0x21, 0x0f, 0x80, 0x1d, 0x30, 0x01, 0x17,
        0xe5, 0x1a, 0xfd, 0x7c, 0x00, 0xf4, 0xff, 0xef, 0x54, 0x0f,
        0xfe, 0xee, 0x42, 0x21, 0xed, 0x54, 0xf0, 0xfe, 0xee, 0x42,
        0x26, 0x80, 0x03, 0x43, 0x26, 0xf0, 0xab, 0x27, 0xaa, 0x26,
        0x7d, 0x0d, 0x7f, 0x01, 0x12, 0x32, 0x06, 0x12, 0x44, 0xe3,
        0x7f, 0x1e, 0x12, 0x45, 0xb9, 0x7a, 0x00, 0xe5, 0x17, 0x54,
        0xfe, 0xfb, 0xe4, 0xfd, 0x7f, 0x01, 0x12, 0x32, 0x06, 0xe4,
        0xfb, 0xfa, 0x7d, 0x0f, 0x7f, 0x01, 0x12, 0x32, 0x06, 0x02,
        0x42, 0x4a, 0xe5, 0x24, 0x30, 0xe1, 0x0a, 0xa8, 0x1d, 0xe6,
        0x20, 0xe1, 0x15, 0x7f, 0x02, 0x80, 0x0e, 0xe5, 0x24, 0x54,
        0x60, 0xff, 0xbf, 0x20, 0x04, 0x7f, 0x01, 0x80, 0x02, 0xe4,
        0xff, 0x12, 0x45, 0x4c, 0xa8, 0x1d, 0xa6, 0x24, 0x05, 0x18,
        0x05, 0x1d, 0x02, 0x41, 0x07, 0x30, 0x02, 0x0e, 0x7b, 0x00,
        0x7a, 0x40, 0x7d, 0x1c, 0x7f, 0x04, 0x12, 0x32, 0x06, 0x12,
        0x45, 0x8f, 0xd0, 0x23, 0xd0, 0x23, 0x02, 0x30, 0x2c, 0x22,
        0xfa, 0xab, 0x22, 0x7d, 0x03, 0x7f, 0x01, 0x12, 0x32, 0x06,
        0x12, 0x45, 0x8f, 0x7f, 0x06, 0x12, 0x45, 0xb9, 0x7d, 0x1c,
        0x7f, 0x04, 0x12, 0x31, 0xee, 0xef, 0x22, 0xab, 0x27, 0xaa,
        0x26, 0x7d, 0x0d, 0x7f, 0x01, 0x12, 0x32, 0x06, 0x22, 0xfb,
        0x7a, 0x00, 0xe4, 0xfd, 0x7f, 0x01, 0x12, 0x32, 0x06, 0x22,
        0xab, 0x22, 0xaa, 0x21, 0x7d, 0x0e, 0x7f, 0x01, 0x12, 0x32,
        0x06, 0x22, 0x7d, 0x12, 0x7f, 0x04, 0x12, 0x31, 0xee, 0x8e,
        0x21, 0x8f, 0x22, 0xe5, 0x22, 0x54, 0x0f, 0x24, 0xfc, 0x70,
        0x3b, 0xe5, 0x21, 0x54, 0x0f, 0xf5, 0x23, 0x24, 0xa1, 0xf5,
        0x1f, 0xe5, 0x22, 0x64, 0x24, 0x70, 0x08, 0x85, 0x23, 0xfb,
        0x7f, 0x02, 0x12, 0x45, 0x4c, 0xe5, 0x22, 0x64, 0x04, 0xa8,
        0x1f, 0x70, 0x06, 0x74, 0x80, 0x46, 0xf6, 0x80, 0x04, 0x74,
        0x7f, 0x56, 0xf6, 0x05, 0x1f, 0x05, 0x23, 0xe5, 0x23, 0xc3,
        0x94, 0x0c, 0x50, 0x14, 0xe5, 0x21, 0x20, 0xe4, 0xd0, 0x22,
        0xe5, 0x21, 0x44, 0x40, 0xfa, 0xab, 0x22, 0x7d, 0x12, 0x7f,
        0x04, 0x12, 0x32, 0x06, 0x22, 0x8f, 0x2a, 0xe4, 0xf5, 0x4b,
        0xf5, 0x4c, 0xb5, 0x2a, 0x01, 0x04, 0xf5, 0x4a, 0x7f, 0x88,
        0x7e, 0x0f, 0x12, 0x31, 0x67, 0x7b, 0x80, 0x7a, 0x99, 0xe5,
        0x2a, 0x30, 0xe1, 0x04, 0x7b, 0x00, 0x7a, 0x00, 0x7d, 0x17,
        0x7f, 0x01, 0x02, 0x32, 0x06, 0xe5, 0xed, 0xc4, 0x54, 0x0f,
        0xf5, 0xed, 0x85, 0xea, 0xe9, 0xe4, 0xf5, 0xed, 0xf5, 0xe9,
        0xc2, 0x61, 0x53, 0x91, 0xdf, 0xd2, 0xe9, 0xd0, 0x23, 0xd0,
        0x23, 0x22, 0x7b, 0xc0, 0x7a, 0x00, 0x7d, 0x1a, 0x7f, 0x04,
        0x12, 0x32, 0x06, 0x7b, 0x80, 0x7a, 0x00, 0x7d, 0x1a, 0x7f,
        0x04, 0x02, 0x32, 0x06, 0xe5, 0x24, 0x54, 0x03, 0x70, 0x0d,
        0x7f, 0x84, 0x7e, 0x07, 0x12, 0x2f, 0x0b, 0xe5, 0x4c, 0x54,
        0x06, 0x70, 0xf3, 0x22, 0x8f, 0x28, 0x75, 0x29, 0x07, 0x7d,
        0x1c, 0xe4, 0xff, 0x12, 0x31, 0xee, 0xd5, 0x29, 0xf6, 0xd5,
        0x28, 0xf0, 0x22, 0x78, 0xa1, 0x79, 0x95, 0x7d, 0x0c, 0x76,
        0x88, 0x77, 0x00, 0x08, 0x09, 0xdd, 0xf8, 0x22
    };

#if PHY_DEBUG
    println_str("atom_8051_patch_13_10_2010");
#endif

    VTSS_RC(atom_download_8051_code(phy, &vga_arr[0], sizeof(vga_arr)));
    return VTSS_RC_OK;
}

#endif // End VTSS_ATOM12_A


#if VTSS_ATOM12_B
// Atom  Rev. B. Internal 8051 patch.
// In     : port_no - any port within the chip where to load the 8051 code.
// Return : VTSS_RC_OK if configuration done else error code.
// Date:  26-Oct-2012
// Initializes micro patch for entire 12-port chip containing specified PHY
static vtss_rc luton26_atom12_revB_patch(vtss_port_no_t port_no)
{
    static code const u8 patch_arr[] = {
        0x43, 0xe9, 0x02, 0x40, 0x58, 0x02, 0x40, 0x4e, 0x02, 0x44,
        0x00, 0x02, 0x42, 0x2b, 0x02, 0x41, 0x82, 0x74, 0x05, 0xfb,
        0x02, 0x08, 0x21, 0x94, 0x14, 0xec, 0x64, 0x80, 0x94, 0x80,
        0x50, 0x12, 0xe5, 0x51, 0x24, 0x18, 0x12, 0x16, 0xea, 0x12,
        0x17, 0x54, 0xe4, 0xf0, 0xa3, 0x74, 0x24, 0x02, 0x0a, 0xf6,
        0xe9, 0x12, 0x17, 0xbd, 0xe5, 0x51, 0x24, 0x18, 0x12, 0x16,
        0xea, 0x12, 0x17, 0x54, 0xe4, 0x75, 0xf0, 0x10, 0x02, 0x0b,
        0x0b, 0x12, 0x43, 0x6d, 0x02, 0x09, 0xde, 0x12, 0x42, 0xcf,
        0xd0, 0x1d, 0xd0, 0x1d, 0x02, 0x39, 0xb1, 0xe4, 0xf5, 0x28,
        0xf5, 0x29, 0xe5, 0x1e, 0x54, 0x0f, 0x64, 0x09, 0x60, 0x03,
        0x02, 0x41, 0x77, 0xfb, 0xfa, 0x7d, 0xff, 0x7f, 0x92, 0x12,
        0x35, 0xdb, 0x53, 0x91, 0x7f, 0xa2, 0xaf, 0x92, 0x08, 0xc2,
        0xaf, 0x75, 0xff, 0x10, 0x75, 0xfd, 0x84, 0x75, 0xfe, 0xb7,
        0x75, 0xfc, 0x94, 0xe5, 0xfc, 0x30, 0xe0, 0xfb, 0x12, 0x43,
        0xff, 0x75, 0xff, 0x11, 0xe4, 0xff, 0xf5, 0xfb, 0xe5, 0xfb,
        0xd3, 0x94, 0x0b, 0x50, 0x25, 0x75, 0xfc, 0xd0, 0xe5, 0xfc,
        0x30, 0xe0, 0xfb, 0xe5, 0xfd, 0x54, 0x3c, 0xfe, 0xbe, 0x2c,
        0x11, 0xae, 0x07, 0x0f, 0x74, 0x22, 0x2e, 0xf8, 0xa6, 0xfb,
        0xc3, 0xef, 0x64, 0x80, 0x94, 0x86, 0x50, 0x04, 0x05, 0xfb,
        0x80, 0xd4, 0xd3, 0xef, 0x64, 0x80, 0x94, 0x80, 0x50, 0x03,
        0x02, 0x41, 0x63, 0xe4, 0xf5, 0xfb, 0x75, 0xff, 0x10, 0x75,
        0xfd, 0x84, 0x75, 0xfe, 0xb7, 0x75, 0xfc, 0x94, 0xe5, 0xfc,
        0x30, 0xe0, 0xfb, 0x12, 0x43, 0xff, 0xe4, 0xfe, 0x74, 0x22,
        0x2e, 0xf8, 0xe6, 0xf5, 0xfb, 0x75, 0xff, 0x11, 0x75, 0xfc,
        0xd0, 0xe5, 0xfc, 0x30, 0xe0, 0xfb, 0xe5, 0xfd, 0x54, 0x3c,
        0x64, 0x2c, 0x70, 0x4d, 0x75, 0xfe, 0x10, 0xf5, 0xfd, 0x75,
        0xfc, 0x90, 0xe5, 0xfc, 0x30, 0xe0, 0xfb, 0x75, 0xff, 0x10,
        0x75, 0xfe, 0x8f, 0x75, 0xfd, 0x88, 0x75, 0xfc, 0x90, 0xe5,
        0xfc, 0x30, 0xe0, 0xfb, 0x12, 0x43, 0xff, 0x75, 0xff, 0x11,
        0xe4, 0xf5, 0xfe, 0xf5, 0xfd, 0x75, 0xfc, 0x90, 0xe5, 0xfc,
        0x30, 0xe0, 0xfb, 0x75, 0xff, 0x10, 0x75, 0xfe, 0x8f, 0x75,
        0xfd, 0x88, 0x75, 0xfc, 0x90, 0xe5, 0xfc, 0x30, 0xe0, 0xfb,
        0x12, 0x43, 0xff, 0x05, 0x29, 0xe5, 0x29, 0x70, 0x02, 0x05,
        0x28, 0x0e, 0xc3, 0xef, 0x64, 0x80, 0xf8, 0xee, 0x64, 0x80,
        0x98, 0x40, 0x8d, 0xab, 0x29, 0xaa, 0x28, 0x7d, 0x0a, 0x7f,
        0x04, 0x12, 0x3c, 0x26, 0x30, 0xcf, 0x05, 0xc2, 0xcf, 0x12,
        0x42, 0xcf, 0xe5, 0x91, 0x20, 0xe7, 0x03, 0x02, 0x40, 0x7a,
        0xa2, 0x08, 0x92, 0xaf, 0x7b, 0x01, 0x7a, 0x00, 0x7d, 0xee,
        0x7f, 0x92, 0x02, 0x35, 0xdb, 0xe5, 0x1e, 0x20, 0xe5, 0x03,
        0x02, 0x42, 0x2a, 0x90, 0x47, 0xd5, 0x30, 0xe4, 0x33, 0xe0,
        0x54, 0xc7, 0xf0, 0x44, 0x10, 0xf0, 0x90, 0x47, 0xd8, 0xe0,
        0x54, 0x1f, 0xf0, 0xf0, 0xa3, 0xe0, 0x54, 0xf8, 0xf0, 0xf0,
        0x90, 0x47, 0xd5, 0xe0, 0x54, 0x3f, 0xf0, 0x44, 0xc0, 0xf0,
        0xa3, 0xe0, 0x54, 0xfc, 0xf0, 0x44, 0x01, 0xf0, 0x90, 0x47,
        0xdc, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x28, 0xf0, 0x80, 0x2e,
        0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x08, 0xf0, 0x90, 0x47, 0xda,
        0xe0, 0x44, 0x04, 0xf0, 0x90, 0x47, 0xd8, 0xe0, 0x54, 0x1f,
        0xf0, 0x44, 0x40, 0xf0, 0xa3, 0xe0, 0x54, 0xf8, 0xf0, 0xf0,
        0x90, 0x47, 0xd4, 0xe0, 0x54, 0x1f, 0xf0, 0xf0, 0xa3, 0xe0,
        0x54, 0xf8, 0xf0, 0x44, 0x03, 0xf0, 0x90, 0x47, 0xd6, 0xe0,
        0x44, 0x40, 0xf0, 0x90, 0x47, 0xe0, 0xe0, 0x54, 0xf8, 0xf0,
        0x44, 0x05, 0xf0, 0x54, 0x1f, 0xf0, 0x44, 0x40, 0xf0, 0xa3,
        0xe0, 0x54, 0xf8, 0xf0, 0x44, 0x06, 0xf0, 0x90, 0x47, 0xde,
        0xe0, 0x54, 0x1f, 0xf0, 0xf0, 0x54, 0xe3, 0xf0, 0xf0, 0x90,
        0x47, 0xdd, 0xe0, 0x54, 0x7f, 0xf0, 0xf0, 0xa3, 0xe0, 0x54,
        0xfc, 0xf0, 0xf0, 0x22, 0x90, 0x47, 0xd0, 0xe0, 0x54, 0xef,
        0xf0, 0x44, 0x80, 0xf0, 0x90, 0x47, 0xd8, 0xe0, 0x54, 0x7f,
        0xf0, 0x44, 0x80, 0xf0, 0xa3, 0xe0, 0x54, 0xfc, 0xf0, 0xf0,
        0x90, 0x47, 0xd7, 0xe0, 0x54, 0x7f, 0xf0, 0x90, 0x47, 0xda,
        0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x10, 0xf0, 0x90, 0x47, 0xd6,
        0xe0, 0x54, 0xe7, 0xf0, 0x44, 0x18, 0xf0, 0x90, 0x47, 0xd5,
        0xe0, 0x54, 0x8f, 0xf0, 0x44, 0x20, 0xf0, 0x90, 0x47, 0xd4,
        0xe0, 0x54, 0x3f, 0xf0, 0xf0, 0xa3, 0xe0, 0x54, 0xfc, 0xf0,
        0x44, 0x01, 0xf0, 0x90, 0x47, 0xd8, 0xe0, 0x44, 0x04, 0xf0,
        0x90, 0x47, 0xd7, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x18, 0xf0,
        0x7c, 0x00, 0xe5, 0x1e, 0x54, 0x0f, 0xfd, 0x64, 0x01, 0x70,
        0x19, 0xe5, 0x1e, 0x30, 0xe4, 0x14, 0xa3, 0xe0, 0x44, 0x02,
        0xf0, 0x90, 0x47, 0xda, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x18,
        0xf0, 0x54, 0xf8, 0xf0, 0xf0, 0x22, 0xed, 0x64, 0x01, 0x4c,
        0x70, 0x12, 0x90, 0x47, 0xd5, 0xe0, 0x54, 0x7f, 0xf0, 0x44,
        0x80, 0xf0, 0xa3, 0xe0, 0x54, 0xf8, 0xf0, 0x44, 0x07, 0xf0,
        0x90, 0x47, 0xd8, 0xe0, 0x54, 0xfd, 0xf0, 0x22, 0xe4, 0xf5,
        0xfb, 0x7d, 0x1c, 0xe4, 0xff, 0x12, 0x3b, 0xe6, 0xad, 0x07,
        0xac, 0x06, 0xec, 0x54, 0xc0, 0xff, 0xed, 0x54, 0x3f, 0x4f,
        0xf5, 0x20, 0x30, 0x06, 0x2c, 0x30, 0x01, 0x08, 0xa2, 0x04,
        0x72, 0x03, 0x92, 0x07, 0x80, 0x21, 0x30, 0x04, 0x06, 0x7b,
        0xcc, 0x7d, 0x11, 0x80, 0x0d, 0x30, 0x03, 0x06, 0x7b, 0xcc,
        0x7d, 0x10, 0x80, 0x04, 0x7b, 0x66, 0x7d, 0x16, 0xe4, 0xff,
        0x12, 0x3b, 0x25, 0xee, 0x4f, 0x24, 0xff, 0x92, 0x07, 0xaf,
        0xfb, 0x74, 0xaf, 0x2f, 0xf8, 0xe6, 0xff, 0xa6, 0x20, 0x20,
        0x07, 0x39, 0x8f, 0x20, 0x30, 0x07, 0x34, 0x30, 0x00, 0x31,
        0x20, 0x04, 0x2e, 0x20, 0x03, 0x2b, 0xe4, 0xf5, 0xff, 0x75,
        0xfc, 0xc2, 0xe5, 0xfc, 0x30, 0xe0, 0xfb, 0xaf, 0xfe, 0xef,
        0x20, 0xe3, 0x1a, 0xae, 0xfd, 0x44, 0x08, 0xf5, 0xfe, 0x75,
        0xfc, 0x80, 0xe5, 0xfc, 0x30, 0xe0, 0xfb, 0x8f, 0xfe, 0x8e,
        0xfd, 0x75, 0xfc, 0x80, 0xe5, 0xfc, 0x30, 0xe0, 0xfb, 0x05,
        0xfb, 0xaf, 0xfb, 0xef, 0xc3, 0x94, 0x0c, 0x50, 0x03, 0x02,
        0x42, 0xd2, 0xe4, 0xf5, 0xfb, 0x22, 0xe4, 0xf5, 0x4b, 0x75,
        0x4c, 0x01, 0xf5, 0x4d, 0x7f, 0x40, 0x7e, 0x02, 0x12, 0x3b,
        0x4e, 0xe4, 0xf5, 0x2a, 0xe5, 0x2a, 0x25, 0xe0, 0x24, 0xc9,
        0xf5, 0x82, 0xe4, 0x34, 0x43, 0xf5, 0x83, 0xe4, 0x93, 0xfe,
        0x74, 0x01, 0x93, 0xf5, 0x4b, 0xee, 0xff, 0x8f, 0x4c, 0xe5,
        0x4c, 0x30, 0xe7, 0x04, 0x7f, 0xff, 0x80, 0x02, 0x7f, 0x00,
        0x8f, 0x4d, 0xe5, 0x2a, 0x25, 0xe0, 0xff, 0xe4, 0x33, 0x44,
        0x02, 0xfe, 0x12, 0x3b, 0x4e, 0x05, 0x2a, 0xe5, 0x2a, 0xc3,
        0x94, 0x10, 0x40, 0xc4, 0xe4, 0xf5, 0x4b, 0xf5, 0x4c, 0xf5,
        0x4d, 0x7f, 0x40, 0x7e, 0x02, 0x02, 0x3b, 0x4e, 0x17, 0x55,
        0xfc, 0xaf, 0xeb, 0x8c, 0xd9, 0xec, 0x7f, 0xff, 0x45, 0x31,
        0xbb, 0x3e, 0x15, 0xee, 0xf8, 0x8a, 0xd9, 0x60, 0xf4, 0x6b,
        0xf5, 0xde, 0x01, 0xa4, 0xfb, 0xf4, 0xeb, 0xf4, 0xfc, 0x03,
        0xc2, 0xe9, 0xc2, 0x61, 0x75, 0xe9, 0xff, 0x75, 0xed, 0x0f,
        0x90, 0x47, 0xfe, 0xe0, 0x54, 0xf8, 0x44, 0x02, 0xf0, 0xd2,
        0x6c, 0x22, 0x22, 0x22
    };
    VTSS_RC(atom_download_8051_code(port_no, &patch_arr[0], sizeof(patch_arr)));

    VTSS_RC(vtss_phy_wr(port_no,  0, 0x4018));     // Enable 8051 clock; clear patch present; disable PRAM clock override and addr. auto-incr; operate at 125 MHz
    VTSS_RC(vtss_phy_wr(port_no,  0, 0xc018));     // Release 8051 SW Reset

    // Check that code is downloaded correctly.
    VTSS_RC(vtss_phy_is_8051_crc_ok_private(port_no,
                                            FIRMWARE_START_ADDR,
                                            sizeof(patch_arr) + 1, // Add one for the byte auto-added in the download function
                                            0xB2AA));

    VTSS_RC(vtss_phy_wr(port_no, 31, 0x0010));     // Switch back to micro/GPIO register-page
    VTSS_RC(vtss_phy_micro_assert_reset(port_no));
    VTSS_RC(vtss_phy_wr(port_no, 31, 0x0010));     // Switch back to micro/GPIO register-page
    VTSS_RC(vtss_phy_wr(port_no,  3, 0x081c));     // ROM addr. to trap for patch0
    VTSS_RC(vtss_phy_wr(port_no,  4, 0x4012));     // PRAM jump addr. for patch0
    VTSS_RC(vtss_phy_wr(port_no,  5, 0x0ade));     // ROM addr. to trap for patch1
    VTSS_RC(vtss_phy_wr(port_no,  6, 0x4018));     // PRAM jump addr. for patch1
    VTSS_RC(vtss_phy_wr(port_no,  7, 0x06df));     // ROM addr. to trap for patch2
    VTSS_RC(vtss_phy_wr(port_no,  8, 0x06fd));     // PRAM jump addr. to patch around invalid x-short preservation
    VTSS_RC(vtss_phy_wr(port_no,  9, 0x09db));     // ROM addr. to trap for patch3
    VTSS_RC(vtss_phy_wr(port_no, 10, 0x4048));     // PRAM jump addr. for patch3
    VTSS_RC(vtss_phy_wr(port_no, 12, 0x0f00));     // set bit 11:8 to enable patch0-3 trapping
    VTSS_RC(vtss_phy_wr(port_no,  0, 0x4098));     // Enable 8051 clock; indicate patch present; disable PRAM clock override and addr. auto-incr; operate at 125 MHz
    VTSS_RC(vtss_phy_wr(port_no,  0, 0xc098));     // Release 8051 SW Reset
    VTSS_RC(vtss_phy_wr(port_no, 31, 0x0000));     // Switch back to main register-page

    return VTSS_RC_OK;
}
#endif /* VTSS_ATOM12_B */


#if VTSS_ATOM12_B
static vtss_rc vtss_phy_65nm_10BASE_init(const vtss_port_no_t port_no,
                                         const u8 invert_pulse) {
    int i;
    u16 msb, lsw, tr_cmd;
    const tr_base_reg_write_cmd = 0x8486;
    const tr_last_reg_write_cmd = 0x84b4;


#ifdef VTSS_10BASE_TE
static u8 tr_reg_bits_msb[] = {
    0x00,   0x65,   0x00,   0xeb,   0x00,   0x65,   0x59,   0x48,   //0x8486 - 0x8494
    0x00,   0xeb,   0x00,   0x55,   0x00,   0x00,   0x51,   0x30,   //0x8496 - 0x84a4
    0x10,   0x00,   0x00,   0x29,   0x79,   0x71,   0x61,   0x59    //0x84a6 - 0x84b4
};
static u16 tr_reg_bits_lsw[] = {
    0xf410, 0xb719, 0x0914, 0xcefb, 0x0eb9, 0x6596, 0x2492, 0xa02a, //0x8486 - 0x8494
    0x0ab6, 0xcef9, 0x0caa, 0x5555, 0x0555, 0x0015, 0x240e, 0xa206, //0x8496 - 0x84a4
    0x2000, 0x0000, 0x0000, 0x2659, 0xf79d, 0xb699, 0x6596, 0x6596  //0x84a6 - 0x84b4
};
#else //System uses regular 10BASE-T to support Cat3 (and uglier) cables
static u8 tr_reg_bits_msb[] = {
    0x20,   0x75,   0x00,   0xf7,   0x00,   0x49,   0x41,   0x40,   //0x8486 - 0x8494
    0x00,   0xf7,   0x00,   0x49,   0x00,   0x00,   0x38,   0x00,   //0x8496 - 0x84a4
    0x00,   0x00,   0x00,   0x29,   0x7d,   0x75,   0x41,   0x41    //0x84a6 - 0x84b4
};
static u16 tr_reg_bits_lsw[] = {
    0xa497, 0xf71a, 0x0a14, 0xff7a, 0x0db2, 0x2410, 0x0410, 0xca39, //0x8486 - 0x8494
    0x0eff, 0xff7a, 0x0db2, 0x2492, 0x0410, 0x0010, 0xc244, 0x0000, //0x8496 - 0x84a4
    0x0000, 0x0000, 0x0000, 0x265d, 0xf7df, 0x9551, 0x0410, 0x0410  //0x84a6 - 0x84b4
};
#endif /* VTSS_10BASE_TE */



    //Configure 10BASE-Te (EEE reduced transmit amplitude spec for 10Mb)
    VTSS_RC(vtss_phy_wr(port_no, 31, 0x0002));
#ifdef VTSS_10BASE_TE
    VTSS_RC(vtss_phy_wr_masked(port_no, 16, 0x0007, 0x000f));
    VTSS_RC(vtss_phy_wr_masked(port_no, 17, 0x8000, 0x8000));
#else //System uses regular 10BASE-T to support Cat3 (and uglier) cables
    VTSS_RC(vtss_phy_wr_masked(port_no, 17, 0x0000, 0x8000));
#endif /* VTSS_10BASE_TE */

    VTSS_RC(vtss_phy_wr(port_no, 31, 0x52b5));


    for ( tr_cmd = tr_base_reg_write_cmd, i = 0; tr_cmd <= tr_last_reg_write_cmd;
          tr_cmd += 2, ++i ) {
        msb = tr_reg_bits_msb[i];
        lsw = tr_reg_bits_lsw[i];
	if (invert_pulse) {
	    if (tr_cmd == 0x848a)
                lsw ^= 0x1040;
	    else {
                msb ^= 0x82;
                lsw ^= 0x0820;
	    }
	}
        VTSS_RC(vtss_phy_wr(port_no, 18, msb));
        VTSS_RC(vtss_phy_wr(port_no, 17, lsw));
        VTSS_RC(vtss_phy_wr(port_no, 16, tr_cmd));
    }

    return VTSS_RC_OK;
}
#endif // VTSS_ATOM12_B


#if VTSS_ATOM12_B
// Initialization need for ATOM12 rev. B. (For whole chip and must be done before init. of the individual ports)
//
// In : phy - Any port within the chip.
//
// Return : VTSS_RC_OK if configuration done else error code.
//Id: init_script.m,v 1.21 2011/07/11 21:45:17 jimb Exp

//Initializes entire 12-port chip containing specified PHY
static vtss_rc luton26_atom12_revB_init_script(int phy)
{
    VTSS_RC(vtss_phy_wr(phy, 31, 0x0000));
    VTSS_RC(vtss_phy_wr_masked(phy, 22, 0x0001, 0x0001)); //Turn ON broadcast to all 12 PHYs
    VTSS_RC(vtss_phy_wr(phy, 24, 0x2040));
    VTSS_RC(vtss_phy_wr(phy, 31, 0x0002));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x02f0));
    VTSS_RC(vtss_phy_wr(phy, 31, 0x2a30));
    VTSS_RC(vtss_phy_wr(phy, 20, 0x6530));
    VTSS_RC(vtss_phy_wr(phy,  9, 0x1800));
    VTSS_RC(vtss_phy_wr(phy,  8, 0x8212));
    VTSS_RC(vtss_phy_wr(phy, 31, 0x52b5));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0001));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fe6));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x1b00));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fa0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0001));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xe489));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f92));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x000f));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0151));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fe0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0011));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96a0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x7100));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96a2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x00d2));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x547f));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x968c));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x00f0));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xf00d));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96b0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x7620));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96b2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x345f));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96b4));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0012));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x481a));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f82));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x000e));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x2d00));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fb0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x83a6));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0007));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xd6bb));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x83ae));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0004));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xbf81));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x9688));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0013));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x292a));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fa4));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x003c));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x3800));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f8a));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0422));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f86));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x000f));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x001c));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fac));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0068));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x81c0));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f90));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xf7df));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fd4));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xffdf));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fd2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0085));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xf3c6));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x97a0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x07c2));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x97a2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x002b));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x2dff));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x9794));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x00ba));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fe2));

    // Bugzilla#8183 - Ports with different speeds can get link up.
    VTSS_RC(vtss_phy_wr(phy, 16, 0xa7fe));
    VTSS_RC(vtss_phy_wr_masked(phy, 17, 0x0004, 0x000c));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x87fe));

    VTSS_RC(vtss_phy_65nm_10BASE_init(phy, 0));

    VTSS_RC(vtss_phy_wr(phy, 31, 0x2a30));
    VTSS_RC(vtss_phy_wr(phy,  8, 0x0212));
    VTSS_RC(luton26_atom12_revB_patch(phy)); // Download Luton26/Atom12 Rev. B patch

    VTSS_RC(vtss_phy_wr(phy, 31, 0x0000));
    VTSS_RC(vtss_phy_wr_masked(phy, 22, 0x0000, 0x0001)); //Turn off broadcast to all 12 PHYs

    return VTSS_RC_OK;
}

#endif // VTSS_ATOM12_B

#if VTSS_ATOM12_C || VTSS_ATOM12_D

// Atom  Rev. C. Internal 8051 patch.
// In     : port_no - any port within the chip where to load the 8051 code.
// Return : VTSS_RC_OK if configuration done else error code.

// Initializes micro patch for entire 12-port chip containing specified PHY
static vtss_rc luton26_atom12_revC_patch(vtss_port_no_t port_no) {
    const u8 patch_arr[] = {
        0x42, 0x5e, 0x02, 0x42, 0x53, 0x02, 0x42, 0x68, 0x02, 0x42,
        0x6b, 0x02, 0x40, 0xd1, 0x02, 0x41, 0x62, 0xef, 0x03, 0x03,
        0xf5, 0x62, 0x02, 0x1d, 0xf2, 0x12, 0x41, 0xcb, 0x02, 0x09,
        0xbb, 0xed, 0xff, 0xe5, 0xfc, 0x54, 0x38, 0x64, 0x20, 0x70,
        0x08, 0x65, 0xff, 0x70, 0x04, 0xed, 0x44, 0x80, 0xff, 0x22,
        0xe4, 0xf5, 0xfb, 0x7d, 0x1c, 0xe4, 0xff, 0x12, 0x3c, 0x2a,
        0xad, 0x07, 0xac, 0x06, 0xec, 0x54, 0xc0, 0xff, 0xed, 0x54,
        0x3f, 0x4f, 0xf5, 0x20, 0x30, 0x06, 0x2c, 0x30, 0x01, 0x08,
        0xa2, 0x04, 0x72, 0x03, 0x92, 0x07, 0x80, 0x21, 0x30, 0x04,
        0x06, 0x7b, 0xcc, 0x7d, 0x11, 0x80, 0x0d, 0x30, 0x03, 0x06,
        0x7b, 0xcc, 0x7d, 0x10, 0x80, 0x04, 0x7b, 0x66, 0x7d, 0x16,
        0xe4, 0xff, 0x12, 0x3b, 0x49, 0xee, 0x4f, 0x24, 0xff, 0x92,
        0x07, 0xaf, 0xfb, 0x74, 0xb6, 0x2f, 0xf8, 0xe6, 0xff, 0xa6,
        0x20, 0x20, 0x07, 0x39, 0x8f, 0x20, 0x30, 0x07, 0x34, 0x30,
        0x00, 0x31, 0x20, 0x04, 0x2e, 0x20, 0x03, 0x2b, 0xe4, 0xf5,
        0xff, 0x75, 0xfc, 0xc2, 0xe5, 0xfc, 0x30, 0xe0, 0xfb, 0xaf,
        0xfe, 0xef, 0x20, 0xe3, 0x1a, 0xae, 0xfd, 0x44, 0x08, 0xf5,
        0xfe, 0x75, 0xfc, 0x80, 0xe5, 0xfc, 0x30, 0xe0, 0xfb, 0x8f,
        0xfe, 0x8e, 0xfd, 0x75, 0xfc, 0x80, 0xe5, 0xfc, 0x30, 0xe0,
        0xfb, 0x05, 0xfb, 0xaf, 0xfb, 0xef, 0xc3, 0x94, 0x0c, 0x50,
        0x03, 0x02, 0x40, 0x36, 0xe4, 0xf5, 0xfb, 0x22, 0x90, 0x47,
        0xd0, 0xe0, 0x54, 0xef, 0xf0, 0x44, 0x80, 0xf0, 0x90, 0x47,
        0xd8, 0xe0, 0x54, 0x7f, 0xf0, 0x44, 0x80, 0xf0, 0xa3, 0xe0,
        0x54, 0xfc, 0xf0, 0xf0, 0x90, 0x47, 0xd7, 0xe0, 0x54, 0x7f,
        0xf0, 0x90, 0x47, 0xda, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x10,
        0xf0, 0x90, 0x47, 0xd6, 0xe0, 0x54, 0xe7, 0xf0, 0x44, 0x18,
        0xf0, 0x90, 0x47, 0xd5, 0xe0, 0x54, 0x8f, 0xf0, 0x44, 0x20,
        0xf0, 0x90, 0x47, 0xd8, 0xe0, 0x44, 0x04, 0xf0, 0x90, 0x47,
        0xd7, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x18, 0xf0, 0x7c, 0x00,
        0xe5, 0x6f, 0x54, 0x0f, 0xfd, 0x64, 0x01, 0x70, 0x19, 0xe5,
        0x6f, 0x30, 0xe4, 0x14, 0xa3, 0xe0, 0x44, 0x02, 0xf0, 0x90,
        0x47, 0xda, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x18, 0xf0, 0x54,
        0xf8, 0xf0, 0xf0, 0x22, 0xed, 0x64, 0x01, 0x4c, 0x70, 0x0f,
        0x90, 0x47, 0xd5, 0xe0, 0x54, 0x7f, 0xf0, 0x44, 0x80, 0x12,
        0x42, 0x4c, 0x44, 0x07, 0xf0, 0x90, 0x47, 0xd8, 0xe0, 0x54,
        0xfd, 0xf0, 0x22, 0xe5, 0x6f, 0x30, 0xe5, 0x63, 0x90, 0x47,
        0xd5, 0x30, 0xe4, 0x30, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x10,
        0xf0, 0x90, 0x47, 0xd8, 0xe0, 0x54, 0x1f, 0xf0, 0x12, 0x42,
        0x4c, 0xf0, 0x90, 0x47, 0xd5, 0xe0, 0x54, 0x3f, 0xf0, 0x44,
        0xc0, 0xf0, 0xa3, 0xe0, 0x54, 0xfc, 0xf0, 0x44, 0x01, 0xf0,
        0x90, 0x47, 0xdc, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x28, 0xf0,
        0x80, 0x1d, 0xe0, 0x54, 0xc7, 0xf0, 0x44, 0x08, 0xf0, 0x90,
        0x47, 0xda, 0xe0, 0x44, 0x04, 0xf0, 0x90, 0x47, 0xd8, 0xe0,
        0x12, 0x42, 0x47, 0xf0, 0x90, 0x47, 0xd6, 0xe0, 0x44, 0x40,
        0xf0, 0x90, 0x47, 0xe0, 0xe0, 0x54, 0xf8, 0xf0, 0x44, 0x05,
        0xf0, 0x12, 0x42, 0x47, 0x44, 0x06, 0xf0, 0x22, 0xe4, 0xf5,
        0x4b, 0x75, 0x4c, 0x01, 0xf5, 0x4d, 0x7f, 0x40, 0x7e, 0x02,
        0x12, 0x3b, 0x72, 0xe4, 0xf5, 0x21, 0xe5, 0x21, 0x25, 0xe0,
        0x24, 0x27, 0xf5, 0x82, 0xe4, 0x34, 0x42, 0xf5, 0x83, 0xe4,
        0x93, 0xfe, 0x74, 0x01, 0x93, 0xf5, 0x4b, 0xee, 0xff, 0x8f,
        0x4c, 0xe5, 0x4c, 0x30, 0xe7, 0x04, 0x7f, 0xff, 0x80, 0x02,
        0x7f, 0x00, 0x8f, 0x4d, 0xe5, 0x21, 0x25, 0xe0, 0xff, 0xe4,
        0x33, 0x44, 0x02, 0xfe, 0x12, 0x3b, 0x72, 0x05, 0x21, 0xe5,
        0x21, 0xc3, 0x94, 0x10, 0x40, 0xc4, 0xe4, 0xf5, 0x4b, 0xf5,
        0x4c, 0xf5, 0x4d, 0x7f, 0x40, 0x7e, 0x02, 0x02, 0x3b, 0x72,
        0x17, 0x55, 0xfc, 0xaf, 0xeb, 0x8c, 0xd9, 0xec, 0x7f, 0xff,
        0x45, 0x31, 0xbb, 0x3e, 0x15, 0xee, 0xf8, 0x8a, 0xd9, 0x60,
        0xf4, 0x6b, 0xf5, 0xde, 0x01, 0xa4, 0xfb, 0xf4, 0xeb, 0xf4,
        0xfc, 0x03, 0x54, 0x1f, 0xf0, 0x44, 0x40, 0xf0, 0xa3, 0xe0,
        0x54, 0xf8, 0xf0, 0x22, 0x7b, 0x01, 0x7a, 0x00, 0x7d, 0xee,
        0x7f, 0x92, 0x02, 0x36, 0x7f, 0x90, 0x47, 0xfe, 0xe0, 0x54,
        0xf8, 0x44, 0x02, 0xf0, 0x22, 0x02, 0x40, 0x33, 0x22
    };
    VTSS_RC(atom_download_8051_code(port_no, &patch_arr[0], sizeof(patch_arr)));

    VTSS_RC(vtss_phy_wr(port_no,  0, 0x4018));     // Enable 8051 clock; clear patch present; disable PRAM clock override and addr. auto-incr; operate at 125 MHz
    VTSS_RC(vtss_phy_wr(port_no,  0, 0xc018));     // Release 8051 SW Reset

    // Check that code is downloaded correctly.
    VTSS_RC(vtss_phy_is_8051_crc_ok_private(port_no,
                                            FIRMWARE_START_ADDR,
                                            sizeof(patch_arr) + 1, // Add one for the byte auto-added in the download function
                                            0x1E5E));

    VTSS_RC(vtss_phy_wr(port_no, 31, 0x0010));     // Switch back to micro/GPIO register-page
    VTSS_RC(vtss_phy_micro_assert_reset(port_no));
    VTSS_RC(vtss_phy_wr(port_no, 31, 0x0010));     // Switch back to micro/GPIO register-page
    VTSS_RC(vtss_phy_wr(port_no,  3, 0x1def));     // ROM addr. to trap for patch0
    VTSS_RC(vtss_phy_wr(port_no,  4, 0x4012));     // PRAM jump addr. for patch0
    VTSS_RC(vtss_phy_wr(port_no,  5, 0x09b8));     // ROM addr. to trap for patch1
    VTSS_RC(vtss_phy_wr(port_no,  6, 0x401a));     // PRAM jump addr. for patch1
    VTSS_RC(vtss_phy_wr(port_no,  7, 0x3c47));     // Trap ROM at _MicroSmiRead+0x1d to spoof patch-presence
    VTSS_RC(vtss_phy_wr(port_no,  8, 0x4020));     // Branch to starting address of SpoofPatchPresence
    VTSS_RC(vtss_phy_wr(port_no, 12, 0x0700));     // set bits 8-10 to enable patch0-2 trapping
    VTSS_RC(vtss_phy_wr(port_no,  0, 0x4018));     // Enable 8051 clock; clear patch present; disable PRAM clock override and addr. auto-incr; operate at 125 MHz
    VTSS_RC(vtss_phy_wr(port_no,  0, 0xc018));     // Release 8051 SW Reset
    VTSS_RC(vtss_phy_wr(port_no, 31, 0x0000));     // Switch back to main register-page

    return VTSS_RC_OK;
}


// Initialization need for ATOM12 rev. C & D. (For whole chip and must be done before init. of the individual ports)
//
// In : phy - Any port with the chip.
//      revision_d - TRUE if chip is a revision D chip. FALSE if it is a revision C.
// Return : VTSS_RC_OK if configuration done else error code.
// Date   : 30-10-2012
static vtss_rc luton26_atom12_revCD_init_script(int phy, BOOL revision_d)
{
    VTSS_RC(vtss_phy_wr(phy, 31, 0x0000));
    VTSS_RC(vtss_phy_wr_masked(phy, 22, 0x0001, 0x0001));
    VTSS_RC(vtss_phy_wr(phy, 24, 0x0040));
    VTSS_RC(vtss_phy_wr(phy, 31, 0x0002));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x02be));
    VTSS_RC(vtss_phy_wr(phy, 31, 0x2a30));
    VTSS_RC(vtss_phy_wr(phy, 20, 0x4420));
    VTSS_RC(vtss_phy_wr(phy, 24, 0x0c00));
    VTSS_RC(vtss_phy_wr(phy,  9, 0x18c8));
    VTSS_RC(vtss_phy_wr_masked(phy,  8, 0x8000, 0x8000));
    VTSS_RC(vtss_phy_wr(phy,  5, 0x1320));

    VTSS_RC(vtss_phy_wr(phy, 31, 0x52b5));
    if (revision_d) {
        VTSS_RC(vtss_phy_wr(phy, 18, 0x0027));
        VTSS_RC(vtss_phy_wr(phy, 17, 0x303d));
        VTSS_RC(vtss_phy_wr(phy, 16, 0x9792));
    }
    else { //VTSS_PHY_ATOM_REV_C
        VTSS_RC(vtss_phy_wr(phy, 18, 0x0032));
        VTSS_RC(vtss_phy_wr(phy, 17, 0x303d));
        VTSS_RC(vtss_phy_wr(phy, 16, 0x9792));
    }
    VTSS_RC(vtss_phy_wr(phy, 18, 0x00a0));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xf147));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x97a0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0005));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x2f54));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fe4));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0004));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x01bd));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fae));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x000f));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x000f));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fac));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0004));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x87fe));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0006));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0150));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fe0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0012));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x480a));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f82));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0034));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f80));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0012));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x82e0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0005));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0208));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x83a2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x9186));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x83b2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x000e));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x3700));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fb0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0004));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x9fa1));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x9688));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xffff));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fd2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0003));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x9fa0));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x968a));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0020));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x640b));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x9690));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x2220));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8258));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x2a20));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x825a));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x3060));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x825c));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x3fa0));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x825e));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xe0f0));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x83a6));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x4489));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f92));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x7000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96a2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0010));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x2048));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96a6));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x00ff));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96a0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0091));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x9880));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fe8));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0004));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xd602));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8fea));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x00ef));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xef00));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96b0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x7100));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96b2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x5064));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x96b4));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0050));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x100f));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x87fa));
#ifndef VTSS_10BASE_TE
    VTSS_RC(vtss_phy_wr(phy, 31, 0x52b5));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0071));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xf6d9));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8488));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0db6));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x848e));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0059));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x6596));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x849c));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0514));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x849e));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0041));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0280));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a4));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a6));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a8));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84aa));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x007d));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xf7dd));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84ae));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x006d));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x95d4));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84b0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0049));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x2410));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84b2));
#else //using 10BASE-Te
    VTSS_RC(vtss_phy_wr(phy, 31, 0x0002));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x8000));
    VTSS_RC(vtss_phy_wr(phy, 31, 0x52b5));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0008));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xa499));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8486));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0075));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xf759));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8488));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0914));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x848a));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x00f7));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xff7b));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x848c));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0eb9));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x848e));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0061));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x85d6));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8490));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0055));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x44d2));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8492));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0044));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xa8aa));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8494));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0cb9));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8496));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x00f7));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xff79));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8498));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0caa));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x849a));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0061));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x8618));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x849c));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0618));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x849e));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0018));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0061));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x848a));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a4));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a6));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84a8));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x0000));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84aa));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0029));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x265d));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84ac));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x007d));
    VTSS_RC(vtss_phy_wr(phy, 17, 0xd658));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84ae));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0061));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x8618));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84b0));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0061));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x8618));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84b2));
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0061));
    VTSS_RC(vtss_phy_wr(phy, 17, 0x8618));
    VTSS_RC(vtss_phy_wr(phy, 16, 0x84b4));
#endif
    // Improve 100BASE-TX link startup robustness to address interop issue   
    VTSS_RC(vtss_phy_wr(phy, 18, 0x0068));    
    VTSS_RC(vtss_phy_wr(phy, 17, 0x8980));    
    VTSS_RC(vtss_phy_wr(phy, 16, 0x8f90));

    VTSS_RC(vtss_phy_wr(phy, 31, 0x2a30));
    VTSS_RC(vtss_phy_wr_masked(phy,  8, 0x0000, 0x8000));
    VTSS_RC(vtss_phy_wr(phy, 31, 0x0000));
    VTSS_RC(vtss_phy_wr_masked(phy, 22, 0x0000, 0x0001));

    //    VTSS_I("luton26_atom12_revCD_init_script done");
    return luton26_atom12_revC_patch(phy);
}



#endif // VTSS_ATOM12_C || VTSS_ATOM12_D

#if VTSS_ATOM12_A
#ifndef _VGA_PATCH_ORIGINAL_
static const struct reg_val {
    uchar   reg;
    ushort  val;
} vga_patch[] = {
    { 31, 0x0000 },
    { 22, 0x3201 },
    { 31, 0x2a30 }, // Switch to test-register page
    { 22, 0x0088 }, // Set band-gap, CAC, and VAC trims
    { 24, 0x0c00 }, // Set input bias current to the 10 setting & Set 1000BASE-T edge-rate to 000
    { 31, 0x0000 }, // Switch to main register page
    { 24, 0x0040 }, // Set 100BASE-TX edge-rate to 000
    { 31, 0x0002 }, // Switch to extended-page 2
    { 16, 0x67f0 }, // Set Cu default amplitude
    { 31, 0x2a30 }, // Switch to test-register page
    //{ 0, 0x0055 }, // Disable VGA start-up circuit
    {  8, 0x8012 }, // Enable token-ring during coma-mode
    { 31, 0x52b5 }, // Switch to token-ring register page
    { 18, 0x000b },
    { 17, 0x00a0 },
    { 16, 0x8fe0 },
    { 18, 0x000f },
    { 17, 0x8f87 },
    { 16, 0x97d6 },
    { 18, 0x0005 },
    { 17, 0x1900 },
    { 16, 0x8fe4 },
    { 18, 0x0001 },
    { 17, 0x9689 },
    { 16, 0x8f92 },
    { 18, 0x0000 },
    { 17, 0x000c },
    { 16, 0x8fe2 },
    { 18, 0x000d },
    { 17, 0x292a },
    { 16, 0x8fa4 },
    { 18, 0x000d },
    { 17, 0x001c },
    { 16, 0x8fac },
    { 18, 0x0000 },
    { 17, 0x2160 },
    { 16, 0x8258 },
    { 18, 0x0000 },
    { 17, 0x2960 },
    { 16, 0x825a },
    { 18, 0x0000 },
    { 17, 0x3000 },
    { 16, 0x825c },
    { 18, 0x0000 },
    { 17, 0x38b0 },
    { 16, 0x825e },
    { 18, 0x0000 },
    { 17, 0x2150 },
    { 16, 0x8250 },
    { 18, 0x0000 },
    { 17, 0x28d3 },
    { 16, 0x8252 },
    { 18, 0x0000 },
    { 17, 0x37dd },
    { 16, 0x8254 },
    { 18, 0x0000 },
    { 17, 0x3fdd },
    { 16, 0x8256 },
    { 18, 0x0000 },
    { 17, 0x2150 },
    { 16, 0x8248 },
    { 18, 0x0000 },
    { 17, 0x28d3 },
    { 16, 0x824a },
    { 18, 0x0000 },
    { 17, 0x37dd },
    { 16, 0x824c },
    { 18, 0x0000 },
    { 17, 0x3fdd },
    { 16, 0x824e },
    { 18, 0x0001 },
    { 17, 0x40bb },
    { 16, 0x8fda },
    { 18, 0x0000 },
    { 17, 0x015b },
    { 16, 0x8fd6 },
    { 18, 0x0008 },
    { 17, 0xef3f },
    { 16, 0x83ae },
    { 18, 0x0000 },
    { 17, 0x1d00 },
    { 16, 0x8fa0 },
    { 18, 0x0000 },
    { 17, 0x0028 },
    { 16, 0x8f80 },
    { 18, 0x003a },
    { 17, 0xe90a },
    { 16, 0x8f82 },
    { 18, 0x0035 },
    { 17, 0x545f },
    { 16, 0x968c },
    { 18, 0x00ff },
    { 17, 0x0d00 },
    { 16, 0x96b0 },
    { 18, 0x0000 },
    { 17, 0x7100 },
    { 16, 0x96b2 },
    { 18, 0x0000 },
    { 17, 0x8fff },
    { 16, 0x8fd2 },
    { 18, 0x0000 },
    { 17, 0x0500 },
    { 16, 0x8fc0 },
    { 18, 0x0000 },
    { 17, 0x0112 },
    { 16, 0x96a0 },
    { 18, 0x0000 },
    { 17, 0x7000 },
    { 16, 0x96a2 },
    { 18, 0x0020 },
    { 17, 0x2f3f },
    { 16, 0x96a4 },
    { 18, 0x0000 },
    { 17, 0x83df },
    { 16, 0x8fd4 },
    { 18, 0x002b },
    { 17, 0x162e },
};

static void vga_patch_27_09_2010(BOOL luton26_mode, uchar phy)
{
    // Init. script for Luton26/Atom12 PHY
//----------------------------------------------------------------------------------
// Derived from matlab script in
// /group/val/cvs/luton26_atom12/matlab/scripts/luton26_atom12/revA/init_script.m,v
// at the following CVS revision:
// $Id$
//
// with the micro patch coming from
// /group/val/cvs/luton26_atom12/matlab/scripts/luton26_atom12/revA/vga_patch.m,v
// at the following CVS revision:
// $Id$
//----------------------------------------------------------------------------------
    uchar  timeout = 255;
    BOOL   QSGMII_MAC = TRUE;
    int    i;

#if PHY_DEBUG
    println_str("vga_patch_27_09_2010");
#endif

// Turn on broadcast writes so that all PHYs within an Atom12 or Luton26
// package are initialized at the same time

    for (i = 0; i < sizeof(vga_patch) / sizeof(struct reg_val); i++)
        phy_write(phy, vga_patch[i].reg, vga_patch[i].val);



    luton26_vga_patch_appendix(phy);



    phy_write(phy, 31, 0x2a30); // Switch to test-register page
    phy_write(phy,  8, 0x0012); // Undo enable token-ring during coma-mode

// Turn off broadcast writes
    phy_write(phy, 31, 0x0000);
    phy_write(phy, 22, 0x3200);


    // Download patch into PRAM for the internal 8051
    atom_8051_patch_13_10_2010(phy);


// Set patch trap address and patch address for the 2 necessary patches for MCB and a 3rd for VeriPHY
    phy_write(phy, 31, 0x10);
    phy_write(phy, 3, 0x2caa);      // ROM addr. to trap for patch0
    phy_write(phy, 4, 0x400c);      // PRAM jump addr. for patch0
    phy_write(phy, 5, 0x29ed);      // ROM addr. to trap for patch1
    phy_write(phy, 6, 0x4063);      // PRAM jump addr. for patch1
    phy_write(phy, 7, 0x06a2);      // ROM addr. to trap for patch2
    phy_write(phy, 8, 0x40dd);      // PRAM jump addr. for patch2

// Assert/release AuxADC reset to make ready for patch to use
    phy_write(phy, 26, 0x0000);
    phy_write(phy, 26, 0x0080);

// Enable the three traps being used and release the PHY 8051
    phy_write(phy, 12, 0x0700);     // set bit 10:8 to enable patch0-2 trapping
    phy_write(phy, 0, 0x4098);      // Enable 8051 clock; indicate patch present; disable PRAM clock override and addr. auto-incr; operate at 125 MHz
    phy_write(phy, 0, 0xc098);      // Release 8051 SW Reset

//    if (board uses shorted center-tap magnetics) //e.g. luton26/atom12 reference boards, but not luton10 reference boards
    if (0) { //e.g. luton26/atom12 reference boards, but not luton10 reference boards
        phy_write(phy, 18, 0x8025); // Configure for shorted center-tap transformers

        // Wait for micro to complete MCB command to configure for QSGMII
        while (phy_read(phy, 18) & 0x8000 && timeout > 0) {
            timeout--;
        }
    }


    if (!luton26_mode) { // e.g. not for Luton26 internal PHYs
        if (QSGMII_MAC) {
            BOOL FIBER_media = FALSE;

            // Ask micro to configure QSGMII macros via MCB commands
            phy_write(phy, 31, 0x10);

            if (FIBER_media) {
                phy_write_masked(phy, 19, 0x8000, 0x8000);
            }
            phy_write(phy, 18, 0x80a0);
        } else { //Must be a 12xSGMII MAC
            phy_write_masked(phy, 19, 0x4000, 0x4000);
            phy_write(phy, 18, 0x80b0);
        }

        // Wait for micro to complete MCB command to configure for QSGMII
        while (phy_read(phy, 18) & 0x8000 && timeout > 0) {
            timeout--;
        }
    }

    phy_write(phy, 31, 0); // Back to standard page

}
#else
static void vga_patch_27_09_2010(BOOL luton26_mode, uchar phy)
{
    // Init. script for Luton26/Atom12 PHY
//----------------------------------------------------------------------------------
// Derived from matlab script in
// /group/val/cvs/luton26_atom12/matlab/scripts/luton26_atom12/revA/init_script.m,v
// at the following CVS revision:
// $Id$
//
// with the micro patch coming from
// /group/val/cvs/luton26_atom12/matlab/scripts/luton26_atom12/revA/vga_patch.m,v
// at the following CVS revision:
// $Id$
//----------------------------------------------------------------------------------
    uchar  timeout = 255;
    BOOL   QSGMII_MAC = TRUE;

#if PHY_DEBUG
    println_str("vga_patch_27_09_2010");
#endif

// Turn on broadcast writes so that all PHYs within an Atom12 or Luton26
// package are initialized at the same time
    phy_write(phy, 31, 0x0000);
    phy_write(phy, 22, 0x3201);

    phy_write(phy, 31, 0x2a30); // Switch to test-register page
    phy_write(phy, 22, 0x0088); // Set band-gap, CAC, and VAC trims
    phy_write(phy, 24, 0x0c00); // Set input bias current to the 10 setting & Set 1000BASE-T edge-rate to 000

    phy_write(phy, 31, 0x0000); // Switch to main register page
    phy_write(phy, 24, 0x0040); // Set 100BASE-TX edge-rate to 000

    phy_write(phy, 31, 0x0002); // Switch to extended-page 2
    phy_write(phy, 16, 0x67f0); // Set Cu default amplitude

    phy_write(phy, 31, 0x2a30); // Switch to test-register page
//    phy_write(phy,  0, 0x0055); // Disable VGA start-up circuit
    phy_write(phy,  8, 0x8012); // Enable token-ring during coma-mode

    phy_write(phy, 31, 0x52b5); // Switch to token-ring register page
    phy_write(phy, 18, 0xb);
    phy_write(phy, 17, 0xa0);
    phy_write(phy, 16, 0x8fe0);
    phy_write(phy, 18, 0xf);
    phy_write(phy, 17, 0x8f87);
    phy_write(phy, 16, 0x97d6);
    phy_write(phy, 18, 0x5);
    phy_write(phy, 17, 0x1900);
    phy_write(phy, 16, 0x8fe4);
    phy_write(phy, 18, 0x1);
    phy_write(phy, 17, 0x9689);
    phy_write(phy, 16, 0x8f92);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0xc);
    phy_write(phy, 16, 0x8fe2);
    phy_write(phy, 18, 0xd);
    phy_write(phy, 17, 0x292a);
    phy_write(phy, 16, 0x8fa4);
    phy_write(phy, 18, 0xd);
    phy_write(phy, 17, 0x1c);
    phy_write(phy, 16, 0x8fac);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x2160);
    phy_write(phy, 16, 0x8258);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x2960);
    phy_write(phy, 16, 0x825a);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x3000);
    phy_write(phy, 16, 0x825c);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x38b0);
    phy_write(phy, 16, 0x825e);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x2150);
    phy_write(phy, 16, 0x8250);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x28d3);
    phy_write(phy, 16, 0x8252);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x37dd);
    phy_write(phy, 16, 0x8254);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x3fdd);
    phy_write(phy, 16, 0x8256);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x2150);
    phy_write(phy, 16, 0x8248);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x28d3);
    phy_write(phy, 16, 0x824a);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x37dd);
    phy_write(phy, 16, 0x824c);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x3fdd);
    phy_write(phy, 16, 0x824e);
    phy_write(phy, 18, 0x1);
    phy_write(phy, 17, 0x40bb);
    phy_write(phy, 16, 0x8fda);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x15b);
    phy_write(phy, 16, 0x8fd6);
    phy_write(phy, 18, 0x8);
    phy_write(phy, 17, 0xef3f);
    phy_write(phy, 16, 0x83ae);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x1d00);
    phy_write(phy, 16, 0x8fa0);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x28);
    phy_write(phy, 16, 0x8f80);
    phy_write(phy, 18, 0x3a);
    phy_write(phy, 17, 0xe90a);
    phy_write(phy, 16, 0x8f82);
    phy_write(phy, 18, 0x35);
    phy_write(phy, 17, 0x545f);
    phy_write(phy, 16, 0x968c);
    phy_write(phy, 18, 0xff);
    phy_write(phy, 17, 0xd00);
    phy_write(phy, 16, 0x96b0);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x7100);
    phy_write(phy, 16, 0x96b2);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x8fff);
    phy_write(phy, 16, 0x8fd2);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x500);
    phy_write(phy, 16, 0x8fc0);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x112);
    phy_write(phy, 16, 0x96a0);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x7000);
    phy_write(phy, 16, 0x96a2);
    phy_write(phy, 18, 0x20);
    phy_write(phy, 17, 0x2f3f);
    phy_write(phy, 16, 0x96a4);
    phy_write(phy, 18, 0x0);
    phy_write(phy, 17, 0x83df);
    phy_write(phy, 16, 0x8fd4);
    phy_write(phy, 18, 0x2b);
    phy_write(phy, 17, 0x162e);


    luton26_vga_patch_appendix(phy);



    phy_write(phy, 31, 0x2a30); // Switch to test-register page
    phy_write(phy,  8, 0x0012); // Undo enable token-ring during coma-mode

// Turn off broadcast writes
    phy_write(phy, 31, 0x0000);
    phy_write(phy, 22, 0x3200);


    // Download patch into PRAM for the internal 8051
    atom_8051_patch_13_10_2010(phy);


// Set patch trap address and patch address for the 2 necessary patches for MCB and a 3rd for VeriPHY
    phy_write(phy, 31, 0x10);
    phy_write(phy, 3, 0x2caa);      // ROM addr. to trap for patch0
    phy_write(phy, 4, 0x400c);      // PRAM jump addr. for patch0
    phy_write(phy, 5, 0x29ed);      // ROM addr. to trap for patch1
    phy_write(phy, 6, 0x4063);      // PRAM jump addr. for patch1
    phy_write(phy, 7, 0x06a2);      // ROM addr. to trap for patch2
    phy_write(phy, 8, 0x40dd);      // PRAM jump addr. for patch2

// Assert/release AuxADC reset to make ready for patch to use
    phy_write(phy, 26, 0x0000);
    phy_write(phy, 26, 0x0080);

// Enable the three traps being used and release the PHY 8051
    phy_write(phy, 12, 0x0700);     // set bit 10:8 to enable patch0-2 trapping
    phy_write(phy, 0, 0x4098);      // Enable 8051 clock; indicate patch present; disable PRAM clock override and addr. auto-incr; operate at 125 MHz
    phy_write(phy, 0, 0xc098);      // Release 8051 SW Reset

//    if (board uses shorted center-tap magnetics) //e.g. luton26/atom12 reference boards, but not luton10 reference boards
    if (0) { //e.g. luton26/atom12 reference boards, but not luton10 reference boards
        phy_write(phy, 18, 0x8025); // Configure for shorted center-tap transformers

        // Wait for micro to complete MCB command to configure for QSGMII
        while (phy_read(phy, 18) & 0x8000 && timeout > 0) {
            timeout--;
        }
    }


    if (!luton26_mode) { // e.g. not for Luton26 internal PHYs
        if (QSGMII_MAC) {
            BOOL FIBER_media = FALSE;

            // Ask micro to configure QSGMII macros via MCB commands
            phy_write(phy, 31, 0x10);

            if (FIBER_media) {
                phy_write_masked(phy, 19, 0x8000, 0x8000);
            }
            phy_write(phy, 18, 0x80a0);
        } else { //Must be a 12xSGMII MAC
            phy_write_masked(phy, 19, 0x4000, 0x4000);
            phy_write(phy, 18, 0x80b0);
        }

        // Wait for micro to complete MCB command to configure for QSGMII
        while (phy_read(phy, 18) & 0x8000 && timeout > 0) {
            timeout--;
        }
    }

    phy_write(phy, 31, 0); // Back to standard page

}
#endif /* _VGA_PATCH_ORIGINAL_ */
#endif /* VTSS_ATOM12_A */


/************************************************************************/
/* ATOM family API                                                     */
/************************************************************************/


vtss_rc atom12_init_seq_pre (
        vtss_port_no_t      port_no,
        phy_id_t            *phy_id
) {
#if VTSS_ATOM12_A
    BOOL                    luton26_mode;
#endif

#if PHY_DEBUG
    println_str("atom12_init_seq_pre");
#endif

    switch (phy_id->revision)
    {
#if VTSS_ATOM12_A
        case VTSS_PHY_ATOM_REV_A:
            if (phy_id->family == VTSS_PHY_FAMILY_LUTON26)
                luton26_mode = TRUE;
            else
                luton26_mode = FALSE;
            vga_patch_27_09_2010(luton26_mode, port_no);
            break;
#endif

#if VTSS_ATOM12_B
        case VTSS_PHY_ATOM_REV_B:
            luton26_atom12_revB_init_script(port_no);
            break;
#endif

#if VTSS_ATOM12_C
        case VTSS_PHY_ATOM_REV_C:
            luton26_atom12_revCD_init_script(port_no, FALSE);
            break;
#endif

#if VTSS_ATOM12_D
        case VTSS_PHY_ATOM_REV_D:
            luton26_atom12_revCD_init_script(port_no, TRUE);
            break;
#endif

        default:
            print_str("Unsupported ATOM12 revision: ");
            print_dec(phy_id->revision);
            print_cr_lf();
            break;
    }

//#if PERFECT_REACH_LNK_DN
#if 0// default turn off ActiPHY
    phy_page_std(port_no);
    phy_write_masked(port_no, 28, 0x0040, 0x0040);
#endif  /* PERFECT_REACH_LNK_DN */

    return VTSS_RC_OK;
}


/* ------------------------------------------------------------------------ --
 * Purpose     : Initializing 8512/8522/Luton26 PHY
 * Remarks     :
 * Restrictions:
 * Input(s)    : port_no       - Phy port number
 * See also    :
 * Example     :
 ****************************************************************************/
vtss_rc atom12_init_seq (
    vtss_port_no_t  port_no,
    phy_id_t        *phy_id
) {
#if PHY_DEBUG
    println_str("atom12_init_seq");
#endif

#if VTSS_ATOM12_A
    phy_id = 0;
    phy_write(port_no, 31, 0x2a30);
    phy_write(port_no, 25, 1) ; //Inhibit low-power features that may or may not be causing trouble
    phy_write(port_no, 22, 0x1800); // band-gap boost +3 setting, leave cac and vac trims alone for now
    phy_write(port_no, 8, 0x8012); // Make sure TRClk125 is running (needed during COMA)
    phy_write(port_no, 31, 0x52b5);
    phy_write(port_no, 18, 3);
    phy_write(port_no, 17, 0); // Use minimum setting for 10BT line-drivers as all higher-power setting increase 200MHz noise on transmitter
    phy_write(port_no, 16, 0x8fe0);
    phy_write(port_no, 31, 0x2a30);
    phy_write(port_no, 8, 0x8012); // Restore normal gating for TRClk125
    phy_write(port_no, 31, 0x0);
#else
    // Dummy to avoid compile warning
    phy_id = 0;
    port_no = 0;
#endif // End VTSS_ATOM12_A
    return VTSS_RC_OK;
}


#if defined(LUTON26_L25)
vtss_rc atom12_mac_media_if_setup (
    vtss_port_no_t          port_no,
    vtss_phy_reset_conf_t   *conf
) {
    phy_id_t xdata          phy_id;
#if VTSS_ATOM12_B || VTSS_ATOM12_C || VTSS_ATOM12_D
    static BOOL at_least_one_fiber_port = FALSE;
    u16 reg23 = 0;
    u16 reg19g = 0;
    BOOL fi_1000_mode = FALSE; // Use to signal if 1000base-x mode is selected
    BOOL fi_100_mode = FALSE; // Use to signal if 100base-fx mode is selected
#endif // VTSS_ATOM12_B || VTSS_ATOM12_C || VTSS_ATOM12_D

#if PHY_DEBUG
    println_str("atom12_mac_media_if_setup");
#endif

    /* Read PHY id to determine action */
    phy_read_id(port_no, &phy_id);

#if VTSS_ATOM12_A
    if (phy_id.revision == VTSS_PHY_ATOM_REV_A) {
        port_no = 0;
        conf = 0;
        return VTSS_RC_OK;
    }
#endif // VTSS_ATOM12_A

#if VTSS_ATOM12_B || VTSS_ATOM12_C || VTSS_ATOM12_D
    switch (conf->mac_if) {
    case VTSS_PORT_INTERFACE_SGMII:
        reg19g = 1<<14; // SGMII to  CAT5 mode
        reg23  = 0<<12; /* SGMII   */
        break;
    case VTSS_PORT_INTERFACE_SERDES:
        reg19g = 1<<14; // SGMII to  CAT5 mode
        reg23  = 1<<12; //  1000 BASE-X
        break;
    case VTSS_PORT_INTERFACE_QSGMII:
        switch (conf->media_if) {
        case VTSS_PHY_MEDIA_IF_FI_100FX:
        case VTSS_PHY_MEDIA_IF_AMS_CU_100FX:
        case VTSS_PHY_MEDIA_IF_AMS_FI_100FX:
        case VTSS_PHY_MEDIA_IF_FI_1000BX:
        case VTSS_PHY_MEDIA_IF_AMS_FI_PASSTHRU:
        case VTSS_PHY_MEDIA_IF_AMS_CU_1000BX:
        case VTSS_PHY_MEDIA_IF_AMS_FI_1000BX:
            at_least_one_fiber_port = TRUE;
            break;
        default:
            // Copper port, but don't touch at_least_one_fiber_port.
            break;
        }

        //If some ports are copper only, you would not put these ports in an AMS or Fiber mode.  If you always set 19G.14:15 to 10, then you will enable the HSIO to power up the fiber media ports, so if we don't see any fiber ports at all, we keep the HSIO powered down in order to reduce the power consumption.
        if (at_least_one_fiber_port) {
            reg19g = 2<<14; // QSGMII to CAT5 & Fiber mode
        } else {
            reg19g = 0<<14; // QSGMII to CAT5 mode
        }

        break;
    case VTSS_PORT_INTERFACE_NO_CONNECTION:
        reg23 |= 0; //  Shouldn't matter since there is no "interface" for this port
        break;

    default:
      //  VTSS_E("port_no %lu, Mac interface %d not supported",port_no, conf->mac_if);
        return VTSS_RC_ERROR;
    }

    switch (conf->media_if) {
    case VTSS_PHY_MEDIA_IF_CU:
        reg23 |= 0<<8;
        break;
    case VTSS_PHY_MEDIA_IF_SFP_PASSTHRU:
        reg23 |= 1<<8;
            break;
    case VTSS_PHY_MEDIA_IF_FI_1000BX:
        fi_1000_mode = TRUE;
        reg23 |= 2<<8;
        break;
    case VTSS_PHY_MEDIA_IF_FI_100FX:
        fi_100_mode = TRUE;
        reg23 |= 3<<8;
        break;
    case VTSS_PHY_MEDIA_IF_AMS_CU_PASSTHRU:
        reg23 |=  (4<<8);
        break;
    case VTSS_PHY_MEDIA_IF_AMS_FI_PASSTHRU:
        fi_1000_mode = TRUE;
        reg23 |=  (5<<8);
        break;
    case VTSS_PHY_MEDIA_IF_AMS_CU_1000BX:
        fi_1000_mode = TRUE;
        reg23 |=  (6<<8);
        break;
    case VTSS_PHY_MEDIA_IF_AMS_FI_1000BX:
        fi_1000_mode = TRUE;
        reg23 |=  (6<<8);
        break;
    case VTSS_PHY_MEDIA_IF_AMS_CU_100FX:
        fi_100_mode = TRUE;
        reg23 |= (7<<8);
        break;
    case VTSS_PHY_MEDIA_IF_AMS_FI_100FX:
        fi_100_mode = TRUE;
        reg23 |= (7<<8);
        break;
    default:
     //   VTSS_E("port_no %lu, Media interface %d not supported", port_no, conf->media_if);
        return VTSS_RC_ERROR;
    }

    // Setup if CU or fiber is preferred.
   // VTSS_N("cu_preferred = %d", conf->cu_preferred);
    if (conf->cu_preferred) {
        reg23 |= VTSS_F_PHY_EXTENDED_PHY_CONTROL_AMS_PREFERENCE;
    } else {
        reg23 &= ~VTSS_F_PHY_EXTENDED_PHY_CONTROL_AMS_PREFERENCE;
    }

    // Do the register accesses
    vtss_phy_page_gpio(port_no);
    VTSS_RC(vtss_phy_wr_masked(port_no, 19, reg19g, 0xC000));

    // Could be a Luton26 which is also using this function, but shouldn't set the MAC interface
    if (phy_id.family == VTSS_PHY_FAMILY_ATOM) {
#if PHY_DEBUG
        println_str("VTSS_PHY_FAMILY_ATOM : ");
#endif
        VTSS_RC(atom_patch_suspend(port_no, TRUE)); // Suspend 8051 Patch.
        vtss_phy_page_gpio(port_no);
        if (conf->mac_if ==  VTSS_PORT_INTERFACE_QSGMII) {
            VTSS_RC(vtss_phy_wr(port_no, VTSS_PHY_MICRO_PAGE, 0x8020)); // Seee TN1085
        } else {
            VTSS_RC(vtss_phy_wr(port_no, VTSS_PHY_MICRO_PAGE, 0x8030));// Seee TN1085
        }

        // Wait for micro to complete MCB command to configure for QSGMII
        VTSS_RC(vtss_phy_wait_for_micro_complete(port_no));


        vtss_phy_page_gpio(port_no);
        if (fi_100_mode) {
            VTSS_RC(vtss_phy_wr(port_no, VTSS_PHY_MICRO_PAGE , 0x8091 | 0x0100 << (port_no % 4)));
        //    VTSS_D("MCB : Setting 100Fx mode, 0x%X", 0x8091 | 0x0100 << (port_no % 4));
        }

        if (fi_1000_mode) {
            VTSS_RC(vtss_phy_wr(port_no, VTSS_PHY_MICRO_PAGE, 0x8081 | 0x0100 << (port_no % 4)));
          //  VTSS_D("MCB : Setting 1000x mode, 0x%X", 0x8081 | 0x0100 << (port_no % 4));
        }

        // Wait for micro to complete MCB command
        VTSS_RC(vtss_phy_wait_for_micro_complete(port_no));
        VTSS_RC(atom_patch_suspend(port_no, FALSE)); // Resume 8051 Patch.
    }

    vtss_phy_page_std(port_no);
    VTSS_RC(vtss_phy_wr(port_no, 23, reg23));

    // Port must be reset in order to update the media setting for register 23
    VTSS_RC(vtss_phy_wr_masked(port_no, 0, 0x8000, 0x8000));
    delay_1(10);
    vtss_phy_page_std(port_no);
    VTSS_RC(vtss_phy_wr_masked(port_no, 0, 0x0, 0x1000));

    vtss_phy_page_std(port_no);
#endif // VTSS_ATOM12_B || VTSS_ATOM12_C || VTSS_ATOM12_D

    return VTSS_RC_OK;
}
#endif /* defined(LUTON26_L25) */


#if TRANSIT_FAN_CONTROL || TRANSIT_THERMAL
vtss_rc atom12_read_temp_reg (
    vtss_port_no_t  port_no,
    ushort          *temp
)
{
    phy_id_t        phy_id;
    ushort          reg;
#if VTSS_ATOM12_A
    ushort          reg_updated;
    u8              timeout = 255; // Used to make sure that we don't run forever in while loop.
#endif

#if PHY_DEBUG
    println_str("atom12_read_temp_reg");
#endif

    phy_read_id(port_no, &phy_id);

#if VTSS_ATOM12_A
    // Revision A special
    // From Jim B - You need to suspend the 8051 patch prior to triggering the TMON.
    //  I put code in the patch to automatically trigger a temperature reading at the end of the 5ms polling loop,
    // but here is no guarantee that you're not reading in the middle of the patch where we are using the aux-ADC to read out VGA power-up status.
    if ((phy_id.family == VTSS_PHY_FAMILY_ATOM) || (phy_id.family == VTSS_PHY_FAMILY_LUTON26) &&
         phy_id.revision == VTSS_PHY_ATOM_REV_A) {
        atom_patch_suspend(port_no, TRUE);
    }
#endif

    reg = vtss_phy_read_temp(port_no);

#if VTSS_ATOM12_A
    // Revision A special
    if ((phy_id.family == VTSS_PHY_FAMILY_ATOM) || (phy_id.family == VTSS_PHY_FAMILY_LUTON26) &&
         phy_id.revision == VTSS_PHY_ATOM_REV_A)
    {
        // Due to a bug in Atom12 rev A (which is going to fixed in next chip revision) we sometimes get wrong
        // temperature reading. This is a work around that makes sure that these wrong temperatures doesn't make dramatics
        // changes.
        do {
            reg_updated = vtss_phy_read_temp(port_no);

            if (reg_updated == 0xFF || reg_updated == 0x00) {
            } else if (reg_updated > reg) {
                reg++;
            } else {
                reg--;
            }
        } while ((reg_updated != reg) && (timeout-- > 0));

        atom_patch_suspend(port_no, FALSE);
    }

#if PHY_DEBUG
    print_str("Temp retry: ");
    print_dec(255 - timeout);
    println_str(" times.");
#endif
#endif

    phy_page_std(port_no);

    *temp = reg;

    return VTSS_RC_OK;
}
#endif // TRANSIT_FAN_CONTROL || TRANSIT_THERMAL

#endif // VTSS_ATOM12


/****************************************************************************/
/*                                                                          */
/*  End of file.                                                            */
/*                                                                          */
/****************************************************************************/
